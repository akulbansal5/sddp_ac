"""
Simplified GEP solver for a single instance
All parameters are specified within the file
"""

using SDDP
using Gurobi
using Serialization
using CSV, DataFrames

# ============================================================================
# PARAMETERS - Modify these to change the instance and solver settings
# ============================================================================

# Instance parameters
folder = joinpath(@__DIR__, "gep_data")
id     = 56        # instance ID
rep    = 1         # replication number
st     = 10        # number of stages (T)
scens  = 5         # number of scenarios per node

# Solver parameters
threads    = 1
mipgap     = 1e-4
time_limit = 3600   # time limit in seconds (1 hour)
iter_limit = 5      # iteration limit (fixed number of iterations to run)
lb         = 0      # lower bound

# Algorithm parameters
duality_handler  = SDDP.LagrangianDuality()           # or SDDP.LaporteLouveauxDuality()
forward_pass     = SDDP.DefaultMultiForwardPass()     # or SDDP.DefaultNestedForwardPass()
backward_pass    = SDDP.DefaultMultiBackwardPass()    # or SDDP.AnguloMultiBackwardPass()
sampling_scheme  = SDDP.InSampleMonteCarloMultiple()  # or SDDP.AllSampleMonteCarloMultiple()

# Algorithm type: 1 = SDDiP, 2 = Nested Benders
fpass_type = 1

# ---------------------------------------------------------------------------
# Stopping Criteria and Sampling Parameters
# ---------------------------------------------------------------------------

delta        = 0.05       # Convergence tolerance for algorithm stopping
type1_prob   = 1.28       # Type I error quantile (e.g., z-value for 10% one-sided)
type2_prob   = 1.28       # Type II error quantile
M            = 2          # Number of scenario paths sampled per iteration
iter_pass    = 1          # Iteration pass type (e.g., 1 = standard, other values = special handling)
final_run    = false      # For SDDiP: true = traverse entire scenario tree for deterministic bounds
seed         = nothing    # Random seed for reproducibility (nothing = do not set seed)

# Simulation parameters (for out-of-sample evaluation)
postSim = 50       # number of simulation replications
simTime = 3600.0   # simulation time limit

# Model parameters
G = 6              # number of generators
S = 3              # number of subperiods
binCoeff = 6       # binary coefficient for state variable binarization

# ============================================================================
# FUNCTIONS
# ============================================================================

function gep_data_load(folder, fixCost_file, varCost_file)
    """
    Loads fixed and variable cost data from CSV files
    """
    fix_cost = CSV.read(joinpath(folder, fixCost_file), DataFrame)
    var_cost = CSV.read(joinpath(folder, varCost_file), DataFrame)

    select!(fix_cost, Not(:Time))
    select!(var_cost, Not(:Time))

    # Rows represent the year number and columns represent different generators
    # Last column represents the cost of unmet demand
    fix_cost_matrix = Matrix(fix_cost)
    var_cost_matrix = Matrix(var_cost)

    genMax = [4, 10, 10, 1, 45, 4]                              
    genCap = [1130.0, 390.0, 380, 1180, 175, 560]
    genHeat = [8844, 7196, 10842, 10400, 0, 8613]
    genEff = [0.4, 0.56, 0.4, 0.45, 1, 0.48]
    omCost = [4.7, 2.11, 3.66, 0.51, 5, 2.98]
    hours = [271.0, 6556.0, 1933.0]

    return fix_cost_matrix, var_cost_matrix, genMax, genCap, genHeat, genEff, omCost, hours
end

function gep(
    T::Int64,
    G::Int64,
    S::Int64,
    lb::Number,
    binCoeff::Number,
    invCost::Matrix{Float64},
    genCost::Matrix{Float64},
    genMax::Vector{Int64},
    genCap::Vector{Float64},
    genHeat::Vector{Int64},
    genEff::Vector{Float64},
    omCost::Vector{Float64},
    hours::Vector{Float64},
    support::Dict{Int64, Vector{Vector{Any}}},
    threads::Int64,
)
    """
    Generates the SDDP model for GEP problem
    
    Variable mapping:
    x[g] -> U[g, y]: Number of generators of type g to be built in year y
    y[g,s] -> L[g, s, w]: The power generated by generator of type g per hour in
                          sub-period s for scenario w
    u[s] -> E[s, w]: The unserved load per hour in sub-period s for scenario w.
    """
    model = SDDP.LinearPolicyGraph(
        stages = T,
        sense  = :Min,
        lower_bound = lb,
        optimizer = Gurobi.Optimizer,
        solver_threads = threads
    ) do sp, stage

        # Local variables
        @variable(sp, 0 <= x[1:G], integer = true)  # number of generators to use
        
        # Variable y here represents 10 MWHs, other parameters are scaled accordingly
        rescale = 10.0
        @variable(sp, 0 <= y[1:G, 1:S])            # electricity generated per hour in each subperiod
        @variable(sp, 0 <= u[1:S])                 # unmet demand in each subperiod

        # State variables
        @variable(sp, 0 <= h[1:G, 1:binCoeff], Bin, SDDP.State, initial_value = 0)
        @variable(sp, demand[1:S])                 # random parameter for demand for each subperiod

        # Generation capacity -> Constraint (3) in Jin et al. paper
        @constraint(
            sp,
            genCapacity[g in 1:G, s in 1:S],
            (genCap[g]/rescale)*sum(2^(m-1)*h[g, m].out for m in 1:binCoeff) >= y[g, s]
        )
    
        # Limitation on total number of generators -> Constraint (1) in Jin et al. paper
        @constraint(
            sp,
            genLimit[g in 1:G],
            sum(2^(m-1)*h[g, m].out for m in 1:binCoeff) <= genMax[g]
        )

        # Demand satisfaction -> Constraint (2) in Jin et al. paper
        @constraint(
            sp,
            demSatisfy[s in 1:S],
            sum(rescale*y[g, s] for g in 1:G) + u[s] == demand[s]
        )

        # Constraint connecting one stage with the other
        @constraint(
            sp,
            flow[g in 1:G],
            sum(2^(m-1)*h[g, m].out for m in 1:binCoeff) == x[g] + sum(2^(m-1)*h[g, m].in for m in 1:binCoeff)
        )

        SDDP.parameterize(sp, support[stage]) do sample
            dem_sample = sample[1:end-1]
            gas_price  = sample[end]
            rate = 0.08
            if stage != 1
                # Cost for generator of type 2
                genCost[stage, 2] = ((gas_price/1000)*(genHeat[2]/genEff[2]) + omCost[2]*1e-6*(1+0.03)^(stage-1))/((1+rate)^(stage-1))
                
                # Cost for generator of type 3
                # The division by 1000 here is because we are converting gas price from bmtu to btu  
                genCost[stage, 3] = ((gas_price/1000)*(genHeat[3]/genEff[3]) + omCost[3]*1e-6*(1+0.03)^(stage-1))/((1+rate)^(stage-1))
            end

            @stageobjective(
                sp,
                sum(invCost[stage, g]*x[g] for g in 1:G) 
                + sum(rescale*hours[s]*genCost[stage, g]*y[g, s] for g in 1:G for s in 1:S) 
                + sum(hours[s]*invCost[stage, G+1]*u[s] for s in 1:S)       # penalty for missing demand
            )
            
            JuMP.fix.(demand, dem_sample)
        end
    end
    return model
end

function write_results_to_csv(
    folder::String,
    id::Int,
    rep::Int,
    st::Int,
    scens::Int,
    total_time::Float64,
    backward_pass_time::Float64,
    iterations::Int,
    lower_bound::Float64,
    ci_low::Float64,
    ci_high::Float64,
    std_cuts::Int,
    nonstd_cuts::Int,
    duality_handler::String,
    forward_pass::String,
    backward_pass::String,
    sampling_scheme::String,
    fpass_type::Int,
    mipgap::Float64,
    M::Int,
    gap::Float64
)
    """
    Write results to CSV file
    Appends to existing file or creates new one
    """
    csv_file = joinpath(folder, "gep_results.csv")
    
    # Create DataFrame with results
    results_df = DataFrame(
        id = [id],
        rep = [rep],
        stages = [st],
        scens = [scens],
        duality_handler = [duality_handler],
        forward_pass = [forward_pass],
        backward_pass = [backward_pass],
        sampling_scheme = [sampling_scheme],
        fpass_type = [fpass_type],
        mipgap = [mipgap],
        M = [M],
        total_time = [total_time],
        backward_pass_time = [backward_pass_time],
        iterations = [iterations],
        lower_bound = [lower_bound],
        ci_low = [ci_low],
        ci_high = [ci_high],
        gap = [gap],
        std_cuts = [std_cuts],
        nonstd_cuts = [nonstd_cuts]
    )
    
    # Append to CSV file (creates file if it doesn't exist)
    if isfile(csv_file)
        CSV.write(csv_file, results_df, append=true)
    else
        CSV.write(csv_file, results_df)
    end
    
    println("Results written to: $csv_file")
    return csv_file
end

function train_method(
    model,
    duality_handler,
    forward_pass,
    backward_pass,
    sampling_scheme,
    time_limit,
    iter_limit,
    mipgap,
    iter_pass,
    M = 1,
    delta = 0.05,
    fpass_type = 1,
    final_run = false,
    type1_prob = 1.28,
    type2_prob = 1.28,
    seed = nothing
)
    """
    Trains the SDDP model
    fpass_type = 1: SDDiP algorithm
    fpass_type = 2: Nested Benders algorithm
    """
    outputs = nothing

    if fpass_type == 2
        # Nested Benders algorithm
        if iter_limit < 1
            outputs = SDDP.train(
                model;
                duality_handler = duality_handler,
                forward_pass = forward_pass,
                backward_pass = backward_pass,
                sampling_scheme = sampling_scheme,
                stopping_rules = [SDDP.TimeLimit(time_limit), SDDP.NBBoundStalling(delta)],
                mipgap = mipgap,
                iter_pass = iter_pass,
                M = M,
                print_level = 2,
                final_run = final_run
            )
        else
            outputs = SDDP.train(
                model,
                duality_handler = duality_handler,
                forward_pass = forward_pass,
                backward_pass = backward_pass,
                sampling_scheme = sampling_scheme,
                stopping_rules = [SDDP.IterationLimit(iter_limit), SDDP.NBBoundStalling(delta), SDDP.TimeLimit(time_limit)],
                mipgap = mipgap,
                iter_pass = iter_pass,
                M = M,
                print_level = 2,
                final_run = final_run
            )
        end
    else
        # SDDiP algorithm
        if iter_limit < 1
            outputs = SDDP.train(
                model;
                duality_handler = duality_handler,
                forward_pass = forward_pass,
                backward_pass = backward_pass,
                sampling_scheme = sampling_scheme,
                stopping_rules = [SDDP.TimeLimit(time_limit), SDDP.TitoStalling(type1_prob, type2_prob, delta)],
                mipgap = mipgap,
                iter_pass = iter_pass,
                M = M,
                print_level = 2,
                final_run = final_run,
                seed = seed
            )
        else
            outputs = SDDP.train(
                model,
                duality_handler = duality_handler,
                forward_pass = forward_pass,
                backward_pass = backward_pass,
                sampling_scheme = sampling_scheme,
                stopping_rules = [SDDP.IterationLimit(iter_limit), SDDP.TitoStalling(type1_prob, type2_prob, delta), SDDP.TimeLimit(time_limit)],
                mipgap = mipgap,
                iter_pass = iter_pass,
                M = M,
                print_level = 2,
                final_run = final_run,
                seed = seed
            )
        end
    end

    sddp_bound = outputs[1].bb
    sddp_simval = outputs[1].ub

    println("Bound attained from SDDP:            $(sddp_bound)")
    println("Simulation value attained from SDDP: $(sddp_simval)")
    println("================== Training Complete ====================")

    return outputs
end

# ============================================================================
# MAIN EXECUTION
# ============================================================================

println("=" ^ 60)
println("GEP Solver - Single Instance")
println("=" ^ 60)
println("Instance ID: $id, Replication: $rep")
println("Parameters: T=$st, scens=$scens")
println("Algorithm: $(fpass_type == 1 ? "SDDiP" : "Nested Benders")")
println("=" ^ 60)

# Load data
println("\nLoading data files...")
build_time = @elapsed begin
    prefix = "gep"
    fixCost_file = "gep_fixed_cost_jou.csv"
    varCost_file = "gep_varCost_jou.csv"
    fix_cost_matrix, var_cost_matrix, genMax, genCap, genHeat, genEff, omCost, hours = gep_data_load(folder, fixCost_file, varCost_file)
    
    inFile = joinpath(folder, prefix*"_$(id)_$(rep)_$(st)_$(scens).jls")
    support = open(inFile, "r") do f
        deserialize(f)
    end
end
println("Data loaded in $(build_time) seconds")

# Build model
println("\nBuilding SDDP model...")
build_time = @elapsed begin
    model = gep(st, G, S, lb, binCoeff, fix_cost_matrix, var_cost_matrix, genMax, genCap, genHeat, genEff, omCost, hours, support, threads)
end
println("Model built in $(build_time) seconds")

# Train model
println("\nTraining SDDP model...")
train_time = @elapsed begin
    outputs = train_method(
        model,
        duality_handler,
        forward_pass,
        backward_pass,
        sampling_scheme,
        time_limit,
        iter_limit,
        mipgap,
        iter_pass,
        M,
        delta,
        fpass_type,
        final_run,
        type1_prob,
        type2_prob,
        seed
    )
end
println("Training completed in $(train_time) seconds")

# Run simulation (optional)
println("\nRunning out-of-sample simulation...")
simulation_time = @elapsed begin
    simulations = SDDP.simulate(
        model,
        postSim,
        simTime,
        set_sim_seed = true,
        sim_seed = seed === nothing ? 42 : 2*seed
    )

    objectives = map(simulations) do simulation
        return sum(stage[:stage_objective] for stage in simulation)
    end

    μ, ci = SDDP.confidence_interval(objectives)
    sim_lower = μ - ci
    sim_upper = μ + ci
end

println("Simulation completed in $(simulation_time) seconds")
println("\nSimulation Results:")
println("  Mean objective: $(μ)")
println("  Confidence interval: [$sim_lower, $sim_upper]")

# Calculate gap: 100 * (ci_high - lower_bound) / ci_high
gap = if sim_upper != 0.0
    100.0 * (sim_upper - outputs[1].bb) / sim_upper
else
    NaN
end
println("  Gap: $(gap)%")

# Write results to CSV
println("\nWriting results to CSV...")
write_results_to_csv(
    folder,
    id,
    rep,
    st,  # stages
    scens,
    outputs[1].time,  # total_time from training
    outputs[1].backward_pass_time,  # backward_pass_time from training outputs
    outputs[1].iter,  # iterations
    outputs[1].bb,    # lower_bound
    sim_lower,        # ci_low
    sim_upper,        # ci_high
    outputs[1].cs,    # std_cuts
    outputs[1].cns,   # nonstd_cuts
    string(nameof(typeof(duality_handler))),   # duality_handler
    string(nameof(typeof(forward_pass))),      # forward_pass
    string(nameof(typeof(backward_pass))),     # backward_pass
    string(nameof(typeof(sampling_scheme))),   # sampling_scheme
    fpass_type,       # fpass_type (1 = SDDiP, 2 = Nested Benders)
    mipgap,           # mipgap
    M,                # M (number of paths sampled)
    gap               # gap: 100 * (ci_high - lower_bound) / ci_high
)

println("\n" * "=" ^ 60)
println("SUMMARY")
println("=" ^ 60)
println("Build time:      $(build_time) seconds")
println("Training time:   $(train_time) seconds")
println("Simulation time: $(simulation_time) seconds")
println("Total time:      $(build_time + train_time + simulation_time) seconds")
println("=" ^ 60)